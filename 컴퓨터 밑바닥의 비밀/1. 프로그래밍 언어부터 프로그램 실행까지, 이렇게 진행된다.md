# chapter 1. 프로그래밍 언어부터 프로그래밍 실행까지, 이렇게 진행된다 

- 프로그래밍 언어가 컴퓨터 과학의 매우 작은 부분이다.

## 1. 여러분이 프로그래밍 언어를 발명한다면?
- 스위치를 조합하면 불 논리를 표현할 수 있다는 사실을 발견하고 이를 기반으로 CPU를 만들었습니다.

### 1. 창세기: CPU는 똑똑한 바보
- **CPU**는 단세포 생물처럼 원시적 
  예) 데이터를 옮기기, 연산하기
  -> But, 진짜 매우 빠름
- 우린 CPU와 다른 종이다. 서로 대화하기 위해서, **강한자의 언어로 대화해야함**
  -> 초기에는 CPU가 강함 : 프로그래머들은 CPU 관점에서 코드를 작성해야함.

### 2. 어셈블리어 등장
- 기계어와 해당 특정 작업을 간단하게 대응시켜 기계어를 **인간이 읽고이해할 수있는 단어와 대응**시킴
  -> 어셈블리어 탄생
  -> but, 아직까지 일상적으로 사용하는 언어의 형식과 차이가 있음
  -> CPU가 인식할 수 있는 0과 1로 구성된 바이너리로 변환하는 프로그램 필요

### 3. 저수준 계층의 세부 사항 대 고수준 계층의 추상화
- 어셈블리어는 기계어와 마찬가지로 저수준 언어입니다.
- 예시) '저에게 물 한 잔 주세요' -> 인간은 추상적인 표현에 익숙하지만, CPU는 모름
  -> 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환할 수 있는 방법이 있다면 프로그래머의 생산성을 높일 수 있음

### 4. 가득한 규칙: 고급 프로그래밍 언어의 시작
- 우린 CPU에 특정한 작업을 수행하라고 하면 단도직입적으로 말함
- 명령어 세부사항에 차이만 있을 뿐 계속 반복하면, 차이를 매개변수로 분리하고 나머지 명령어를 하나의 함수로 만들면 됨

### 5. 인셉션과 재귀: 코드의 본질
- 세상의 모든 코드는 아무리 복잡하더라도 결과적으로 모두 구문으로 귀결 -> 모든 코드는 구문에 기초하여 작성되기 때문

### 6. 컴퓨터가 재귀를 이해하도록 만들기
- 인간의 글 = 구문들의 모음 = 문자열
- 재귀구문에 따라 작성된 코드를 트리 구조로 표현할 수 있음

### 7. 우수한 번역가: 컴파일러 
- 트리 구조 덕분에 고급 프로그래밍 언어의 발명이 탄생
- 컴파일러는 코드를 CPU가 인식할수있는기계 명령어로 번역하는 역할을 담당

### 8. 해석형 언어의 탄생
- 형식이 다른 CPU는 각각 자신만의 고유한 언어가 있음
- 이를 해결하기 위해, 직접 표준 명령어 집합을 정의해서 CPU의 기계실행 과정을 모방하는 프로그램을 작성하여사용할 수도 있을 것
  -> 한 번의 코드 작성으로 어디서나 그 코드를 실행하는 방법
- 고급 언어는 추상적 표현이 뛰어나서 사용하기 쉽지만 저수준 계층에 대한 제어 능력이 떨어짐.
- 저수준 계층의 세부 사항을 제어할 수 있어야 하는 운영 체제 중 일부분은 어셈블리어로 작성

## 2. 컴파일러는 어떻게 작동하는 것일까?
### 1. 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다.
- 인간이 인식할 수 있는 단어로 코드를 작성하면, 코드는 일반적인 텍스트 파일 형태의 파일(소스 파일)로 저장
  -> 컴파일러가 이를 실행 파일 형태로 뱉어 냄
- 컴파일러 = 번역기, 텍스트 처리 프로그램

### 2. 각각의 토큰 추출하기
```java
int a = 1;
```
1. 키워드(토큰의 의미)
2. int이라는 키워드(토큰이 가지는 값)
이 2개의 정보를 포함하는 토큰(token)이 생성

- 소스 코드에서 토큰을 추출하는 과정을 어휘 분석이라고함

### 3. 토큰이 표현하고자 하는 의미
```kotlin
while (표현식) {
  반복 내용
}
```
- 컴파일러가 while 키워드의 토큰을 찾으면 다음 토큰이 `(`라는 것을 알고 있는 상태에서 기다림
  -> but, `(`이 아니라면, 문법 오류(`syntax error`)를 보고함
  -> 이런 과정을 해석이라고 하며, 컴파일러는 한글자도 놓치지 않고 꼼꼼하게 작업함
  -> 이렇게 해석한 과정은 트리로 표현
  -> 이 트리를 생성하는 전체 과정을 구문 분석이라고 함

### 4. 생성된 구문 트리에 이상은 없을까?
- **의미 분석**을 통해서, 컴파일 오류가 없다는 것을 증명

### 5. 구문 트리를 기반으로 중간 코드 생성하기
- 컴파일러는 구문 트리를 탐색한 결과를 바탕으로 좀 더 다듬어진 형태인 중간 코드를 생성
- 중간 코드에서 추가적인 최적화가 진행

### 6. 코드 생성
- 중간 코드를 어셈블러어 코드로 변환
- 이 어셈블리어 코드를 기계 명령어로 변환
- 3개의 대상 파일을 하나로 묶에주는 것을 링크 작업입니다.
- 링크를 담당하는 프로그램을 링커라고 함

## 3. 링커의 말할 수 없는 비밀

### 1. 링커는 이렇게 일한다
- 링커는 컴파일러가 새성한 대상 파일 여러 개를 하나로 묶어 하나의 최종 실행 파일을 생성
- 컴파일러 함수를 N으로 표시해 두고 넘어간 것을 링커가 실행 파일을 생성하는 과정에서 정화학 주소를 확인하고 N을 실제 메모리 주소로 대체

### 2. 심벌 해석: 수요와 공급
- 심벌은 전역 변수와 함수의 이름을 포함하는 모든 변수 이름
- 지역 변수는 모듈 내에서만 사용되어 외부 모듈에서 참조할 수 없기 때문에 링커의 관심 대상이 아님
- 명령어 부분 : 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장되는 부분입니다. -> 코드 영역
- 데이터 부분 : 소스 파일의 전역 변수가 저장되는 부분입니다. 앞으로 이 부분을 데이터 영역이라고 하겠습니당. -> 데이터 영역
- 참조된 변수 정의를 찾는 일은 링커의 몫
- 컴파일러는 생성한 심벌 테이블을 대상 파일에 저장
